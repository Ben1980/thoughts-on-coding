---
title: A C++ GitHub Template Repository utilizing CircleCI, CMAKE, Docker and Doxygen
description: Post about a C++ GitHub template utilizing different technologies including CI/CD and automatic generation and deployment of the documentation.
date: 2020-04-20
tags:
  - build-automation
  - c++
  - cicd
  - cmake
  - doxygen
  - github-actions
  - vcpkg
layout: layouts/post.njk
image: /img/pexels-panumas-nikhomkhai-1148820.jpg
---

Welcome back to a new post at thoughts-on-coding.com. This time I would like to give an introduction into the structure of my customized [GitHub project template][1] for C++. This C++ project template is consisting of a dummy library and an application that is build by [cmake][2]. The project is utilizing  a [debian][3] based and customized [docker][4] image to run [continuous integration][5] builds (cmake) and executes tests ([ctest][6]) on [CircleCI][7].

![Hero Image: Server, Photo by panumas nikhomkhai from Pexels](/img/pexels-panumas-nikhomkhai-1148820.jpg)

The dependencies of the project are resolved via [vcpkg][8] which can be customized for each deriving project. Additionally, the project is also generating [doxygen][9] based code documentation which is then published to the [gh-pages][10] branch. As always the repository can be found and forked at [GitHub][11] and is available as [v1.1.0][12].

## General Project Structure

The project structure is rather simple. It contains

- An app folder with the actual main function, and a lib folder with all project-related libraries. Both are build by cmake.
- A buildutils directory which holds the python script necessary to convert ctest results into JUnit from.
- An images folder containing all project-related images
- The CircleCI configuration file `.circleci/config.yml`
- A [Dockerfile][13] as which is used to build the docker image necessary to build the project on CircleCI
- A [Doxyfile][14] which configures the documentation generation with doxygen

![Project tree structure with app, lib, build, buildutils, docs, and images directories](/img/projectstructure-min.png)
*Project tree structure with app, lib, build, buildutils, docs, and images directories*

## CircleCI Configuration

Let's start with the CircleCI configuration file `.circleci/config.yml`. At first, an [executor (1)][15] using a customized [docker image (2)][16] is defined. The executor allows the definition of the environment a specific [job][17] in CircleCI is running in. Instead of defining a docker image for each job, an executor can be reused. The project is build upon two jobs, build and test. Each job contains several [steps][18] that have to be fulfilled to make a job successful. The build job is getting the sources from GitHub via the `checkout` command. Afterward, the project dependencies are setup by installing them with vcpkg (3). Then the project tooling is setup (4) and the build process gets started (5). At the end of the build job, it is necessary to [persist (6)][19] the resulting artifacts with a [workspace][20] to use the build results in the following test job. This is necessary because the jobs are independent of each other due to the volatile nature of docker.

First, the test job is starting by loading the [persisted workspace (7)][21] into the job. The actual invocation of ctest (8) might appear a bit strange because of the `|| true`. The reason is that ctest always returns if a test has been successful or not, but in case a test is failing also the CircleCI job would fail which then would prevent the following job steps. At the end of the job step the test results generated by ctest need to be converted (9) into a [JUnit XML][22] conform structure before the test results get [published (10)][23].

The workflow defined at the end of the `.circleci/config.yml` file is defining the actual workflow the build process is following. In this case, the build job is invoked first, followed by the test job which is depending on a successful build job.

```yml
version: 2.1
executors: #(1)
  exectr:
    docker:
      - image: dockerben/cpptemplate:latest #(2)

jobs:
  build:
    executor: exectr #(1)
    steps:
      - checkout
      - run:
          name: Install vcpkg dependencies
          command: ./../../vcpkg/vcpkg install fmt doctest #(3)
      - run:
          name: Create build directories
          command: |
            mkdir -p build
            mv buildutils build/buildutils
      - run:
          name: Setup cmake and build artifacts
          command: |
            cd build
            cmake -DCMAKE_TOOLCHAIN_FILE=/vcpkg/scripts/buildsystems/vcpkg.cmake .. #(4)
            cmake --build . --config Release #(5)
      - persist_to_workspace: #(6)
          root: .
          paths: build

  test:
    executor: exectr #(1)
    steps:
      - attach_workspace: #(7)
          at: .
      - run:
          name: Create test directory
          command: |
            cd build
            mkdir -p Test
      - run:
          name: Execute Tests
          command: |
            cd build
            ctest --no-compress-output -T Test || true #(8)
      - run:
          name: Transform test results into JUnit conform notation
          command: |
            python3 build/buildutils/ctest2JUnit.py build build/buildutils/CTest2JUnit.xsl > build/Test/results.xml #(9)
      - store_test_results: #(10)
          path: build/Test

workflows:
  version: 2
  build-and-test:
    jobs:
      - build #(11)
      - test: #(12)
          requires:
            - build
```

![CircleCI screenshot with a successful workflow](/img/circleciexample-min.png)
*CircleCI screenshot with a successful workflow*

With the [CircleCI CLI][24] there is also a nice tool to test our CircleCI configuration by `sudo circleci local execute` or `sudo circleci local execute JOBNAME` for a specific job to run. The only drawback is that it's not supporting workflows right now, but still, it's enough to test the configuration without nee to commit, maybe broken, code to our repositories.

<video src="/img/circlecicli.mp4" autoplay muted loop >
  Sorry, your browser doesn't support embedded videos,
  but don't worry, you can <a href="/img/circlecicli.mp4">download it</a>
  and watch it with your favorite video player!
</video>
*Example job invocation of the CircleCI CLI*

## Custom Docker Image

CircleCI is using docker images to provide the build environment and therefore it can be completely customized to our needs. Unfortunately, they don't provide a C++ ready [pre-build][25] docker image yet so we have to define our own. If you're not already familiar with the docker basics you should have a look at the docker [overview][26].

To build a custom docker image we need to define a, rather simple,  Dockerfile which starts with a base image (1) where we want to derive from. To build our C++ project we need to install several tools and libraries (2), such as gcc, clang and so on. Additional python is necessary to convert the ctest results into JUnit XML. To resolve the project dependencies we are installing vcpkg (3) and clean up afterward (4) to reduce the resulting docker image size. With 649MB it's anyway quite a big image and there might be tricks to reduce it's size further which I'm not aware of right now.

```dockerfile
FROM debian:stable-slim #(1)

LABEL maintainer="ben.mahr@gmail.com" \
      description="Image which consists of C++ related build tools." \
      version="1.0"

RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \ #(2)
	  git \
	  openssh-server \
	  curl \
	  gcc \
	  g++ \
	  clang \
	  build-essential \
	  cmake \
	  unzip \
	  tar \
	  gzip \
	  sudo \
	  python3 \
	  python3-defusedxml \
	  python3-lxml \
	  libssl-dev \
	  libffi-dev \
	  ca-certificates && \
	  apt-get autoclean && \
          apt-get autoremove && \
          apt-get clean && \
	  rm -rf /var/lib/apt/lists/*

ENV VCPKG_ROOT /vcpkg
ENV CMAKE_TOOLCHAIN_FILE ${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake

RUN git clone https://github.com/microsoft/vcpkg.git && \ #(3)
	  .${VCPKG_ROOT}/bootstrap-vcpkg.sh -disableMetrics && \
	  sudo .${VCPKG_ROOT}/vcpkg integrate install && \
	  rm -rf ${VCPKG_ROOT}/buildtrees/* && \ #(4)
	  rm -rf ${VCPKG_ROOT}/downloads/* #(4)
```

The image can then be build (make sure you're at the same directory as the Dockerfile is) by `sudo docker build -t IMAGENAME .`, afterward the resulting image needs to be tagged by `sudo docker tag IMAGENAME:TAG DOCKERHUBUSERNAME/IMAGENAME:TAG` and then can be pushed to dockerhub by `sudo docker push DOCKERHUBUSERNAME/IMAGENAME:TAG`.

<video src="/img/cpptemplateimage.mp4" autoplay muted loop >
  Sorry, your browser doesn't support embedded videos,
  but don't worry, you can <a href="/img/cpptemplateimage.mp4">download it</a>
  and watch it with your favorite video player!
</video>
*Example of a docker image generation for the cpptemplate*

## Converting Test Results

Because ctest results are not JUnit XML conform, which is a requirement by CircleCI, we have to convert them which is done by a python script and an [xsl transformation][27] (ref. [post][28] by [sakra][29]). Both can be found within the buildutils folder. The python script is using the [ElementTree API][30] of the xml processing package [lxml][31] to process the [xslt file][32]. The script starts by resolving the test results folder, which contains the `Test.xml`, by reading the first line of the `TAG` file (1). In my case e.g. the folder name, derived from the timestamp the tests have been invoked, is called `20200419-1806`. Afterward, the `Test.xml` file gets parsed (2) and the xslt file is then transformed into an XML tree pointing to its root by the `etree.XML()` function (3) which is then converted into an XSLT object (4) which transforms the `Test.xml` (5) into JUnit XML.

```py
from lxml import etree
import io
import sys

TAGfile = open(sys.argv[1]+"/Testing/TAG", 'r') #(1)
dirname = TAGfile.readline().strip()

xslfile = open(sys.argv[2], 'r')
xslcontent = xslfile.read()

xmldoc = etree.parse(sys.argv[1]+"/Testing/"+dirname+"/Test.xml") #(2)
xslt_root = etree.XML(xslcontent) #(3)
transform = etree.XSLT(xslt_root) #(4)

result_tree = transform(xmldoc) #(5)
print(result_tree)
```

## Documentation Generation and Deployment

For the generation and [deployment][11] of the documentation to a gh-pages branch, which is published by GitHub, we use GitHub-Actions. The configuration `.github/workflows/doxygen.yml` of the GitHub-Action starts by defining the events (1) which will invoke the action. In our case, we want to run the action when someone is [pushing][33] or doing a [pull request][34] to the master branch or a change happens to a [Pages-enabled][35] branch. Then the [`doxygen-action`][36] is loaded (2) which simply needs a path to a [Doxyfile][37] (3). The Doxyfile itself is configuring, besides many other settings, the [output format][38] (in our case just HTML) `GENERATE_HTML = YES`, the output path `HTML_OUTPUT = docs`, and the path to related images `IMAGE_PATH = images`. It is clear that the docker configuration needs to be customized for each project. By annotating the [`README.md`][39] with `{#mainpage}` we can use this file as a start page of the documentation. The final step is loading the [`actions-gh-pages`][40] (4) action which is deploying to a gh-pages branch whatever can be found inside the `publish_dir` (5). To avoid the automatic build invocation, by CircleCI, of the gh-pages branch we add a `[ci skip]` statement at each commit message (6). Otherwise, we would always have a broken build caused by the gh-pages branch.

```yml
name: Documentation

on: #(1)
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  page_build:

jobs:
  doxygen:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v1
      - name: Build documentation
        uses: mattnotmitt/doxygen-action@v1 #(2)
        with:
          doxyfile-path: ./Doxyfile #(3)
      - name: Deploy documentation
        uses: peaceiris/actions-gh-pages@v3 #(4)
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs #(5)
          commit_message: '[ci skip] ${{ github.event.head_commit.message }}' #(6)
```

![Circleci screenshot with a master and skipped branch](/img/circleciexample-min.png)
*Circleci screenshot with a master and skipped branch*

## tl;dr

With GitHub template repositories and a bit of customized tooling, including a CI pipeline and automated documentation generation and deployment, we have a good and easy to extend starting point for many C++ projects. Although GitHub template repositories can be used for all certain kinds of projects, it is extremely helpful for C++ projects which are mostly a bit more complex in their setup.

[1]: https://help.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-template-repository
[2]: https://cmake.org/
[3]: https://hub.docker.com/_/debian
[4]: https://www.docker.com/
[5]: https://en.wikipedia.org/wiki/Continuous_integration
[6]: https://gitlab.kitware.com/cmake/community/-/wikis/doc/ctest/Testing-With-CTest
[7]: https://circleci.com/
[8]: https://github.com/microsoft/vcpkg
[9]: http://www.doxygen.nl/
[10]: https://pages.github.com/
[11]: https://github.com/Ben1980/cpptemplate
[12]: https://github.com/Ben1980/cpptemplate/releases/tag/v1.1.0
[13]: https://docs.docker.com/engine/reference/builder/
[14]: http://www.doxygen.nl/manual/starting.html
[15]: https://circleci.com/docs/2.0/configuration-reference/#executors-requires-version-21
[16]: https://circleci.com/docs/2.0/configuration-reference/#docker--machine--macos--windows-executor
[17]: https://circleci.com/docs/2.0/configuration-reference/#jobs
[18]: https://circleci.com/docs/2.0/configuration-reference/#steps
[19]: https://circleci.com/docs/2.0/configuration-reference/#persist_to_workspace
[20]: https://circleci.com/blog/deep-diving-into-circleci-workspaces/?utm_medium=SEM&utm_source=gnb&utm_campaign=SEM-gb-DSA-Eng-ni&utm_content=&utm_term=dynamicSearch-&gclid=EAIaIQobChMIz66Ik8vo6AIVweeaCh0FIQvTEAAYASAAEgIPY_D_BwE
[21]: https://circleci.com/docs/2.0/configuration-reference/#attach_workspace
[22]: https://github.com/windyroad/JUnit-Schema
[23]: https://circleci.com/docs/2.0/configuration-reference/#store_test_results
[24]: https://circleci.com/docs/2.0/local-cli/
[25]: https://circleci.com/docs/2.0/circleci-images/
[26]: https://docs.docker.com/get-started/overview/
[27]: https://de.wikipedia.org/wiki/XSL_Transformation
[28]: https://stackoverflow.com/questions/21633716/producing-ctest-results-in-jenkins-xunit-1-58/21688776#21688776
[29]: https://stackoverflow.com/users/112955/sakra
[30]: http://effbot.org/zone/element-index.htm#documentation
[31]: https://lxml.de/
[32]: https://github.com/Ben1980/cpptemplate/blob/master/buildutils/CTest2JUnit.xsl
[33]: https://help.github.com/en/actions/reference/events-that-trigger-workflows#push-event-push
[34]: https://help.github.com/en/actions/reference/events-that-trigger-workflows#pull-request-event-pull_request
[35]: https://help.github.com/en/actions/reference/events-that-trigger-workflows#page-build-event-page_build
[36]: https://github.com/mattnotmitt/doxygen-action
[37]: https://github.com/Ben1980/cpptemplate/blob/master/Doxyfile
[38]: http://www.doxygen.nl/manual/output.html
[39]: https://github.com/Ben1980/cpptemplate/blob/master/README.md
[40]: https://github.com/peaceiris/actions-gh-pages